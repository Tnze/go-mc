package main

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"io/fs"
	"net/http"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"sync"
	"text/template"

	"github.com/Tnze/go-mc/internal/filesystem"
)

// language=gohtml
var langTmpl = `// Code generated by lang.go; DO NOT EDIT.

package {{.Name}}
{{if ne .Name "en_us"}}
import "github.com/Tnze/go-mc/chat"

func init() { chat.SetLanguage(Map) }
{{end}}
var Map = {{.LangMap | printf "%#v"}}
`

func run(fsys filesystem.FS, httpGetter func(url string) (resp *http.Response, err error), args []string) error {
	if len(args) == 2 {
		fmt.Println("generating en-us lang")
		f, err := fsys.Open(args[1])
		if err != nil {
			return err
		}
		defer f.Close()
		readLang(fsys, "en_us", f)
		return nil
	} else {
		fmt.Println("generating langs except en-us")
		fmt.Println("WARN: You should also set the secondary argument to en-us's json file")
	}

	versionURL, err := assetIndexURL(httpGetter)
	if err != nil {
		return err
	}

	resp, err := httpGetter(versionURL)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("non OK status response %d fetching version data", resp.StatusCode)
	}

	var list struct {
		Objects map[string]struct {
			Hash string `json:"hash"`
			Size int64  `json:"size"`
		} `json:"objects"`
	}

	err = json.NewDecoder(resp.Body).Decode(&list)
	if err != nil {
		return err
	}

	tasks := make(chan string)
	var wg sync.WaitGroup
	for i := 0; i < 16; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for i := range tasks {
				v := list.Objects[i]
				if strings.HasPrefix(i, "minecraft/lang/") {
					name := i[len("minecraft/lang/") : len(i)-len(".json")]
					lang(fsys, httpGetter, name, v.Hash)
				}
			}
		}()
	}
	for i := range list.Objects {
		tasks <- i
	}
	close(tasks)
	wg.Wait()

	return nil
}

func lang(fsys filesystem.FS, httpGetter func(url string) (*http.Response, error), name, hash string) error {
	// download language
	LangURL := "https://resources.download.minecraft.net/" + hash[:2] + "/" + hash
	fmt.Println(name, ":", LangURL)
	resp, err := httpGetter(LangURL)
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	return readLang(fsys, name, resp.Body)
}

// read one language translation
func readLang(fsys filesystem.FS, name string, r io.Reader) error {
	var LangMap map[string]string
	err := json.NewDecoder(r).Decode(&LangMap)
	if err != nil {
		return err
	}
	trans(LangMap)

	pName := strings.ReplaceAll(name, "_", "-")

	err = fsys.Mkdir(pName, 0o777)
	if err != nil && !os.IsExist(err) {
		return err
	}

	genData := struct {
		PkgName string
		Name    string
		LangMap map[string]string
	}{
		PkgName: pName,
		Name:    name,
		LangMap: LangMap,
	}

	var buf bytes.Buffer
	tmpl := template.Must(template.New("").Parse(langTmpl))
	if err := tmpl.Execute(&buf, genData); err != nil {
		return err
	}

	if err := fsys.WriteFile(filepath.Join(pName, name+".go"), buf.Bytes(), fs.ModePerm); err != nil {
		return err
	}

	return nil
}

var javaN = regexp.MustCompile(`%[0-9]\$s`)

// Java use %2$s to refer to the second arg, but Golang use %2s, so we need this
func trans(m map[string]string) error {
	// replace "%[0-9]\$s" with "%[0-9]s"
	var errx error
	for i := range m {
		c := m[i]
		if javaN.MatchString(c) {
			m[i] = javaN.ReplaceAllStringFunc(c, func(s string) string {
				var index int
				_, err := fmt.Sscanf(s, "%%%d$s", &index)
				if err != nil {
					errx = err
					return ""
				}
				return fmt.Sprintf("%%[%d]s", index)
			})
		}
	}

	return errx
}

func assetIndexURL(httpGetter func(url string) (*http.Response, error)) (string, error) {
	// Pseudo code for get versionURL:
	// $manifest = {https://piston-meta.mojang.com/mc/game/version_manifest_v2.json}
	// $latest = $manifest.latest.release
	// $versionURL = {$manifest.versions[where .id == $latest ].url}
	// $assetIndexURL = $version.assetIndex.url
	var manifest struct {
		Latest struct {
			Release string `json:"release"`
		} `json:"latest"`
		Versions []struct {
			ID  string `json:"id"`
			URL string `json:"url"`
		} `json:"versions"`
	}

	manifestRes, err := httpGetter("https://piston-meta.mojang.com/mc/game/version_manifest_v2.json")
	if err != nil {
		return "", fmt.Errorf("could not reach version manifest: %w", err)
	}
	defer manifestRes.Body.Close()

	if manifestRes.StatusCode != http.StatusOK {
		return "", fmt.Errorf("non OK status response %d fetching version manifest", manifestRes.StatusCode)
	}

	if err := json.NewDecoder(manifestRes.Body).Decode(&manifest); err != nil {
		return "", fmt.Errorf("could not decode manifest JSON: %w", err)
	}

	var versionURL string
	for _, v := range manifest.Versions {
		if manifest.Latest.Release == v.ID {
			versionURL = v.URL
			break
		}
	}
	if versionURL == "" {
		return "", errors.New("could not determine versionURL")
	}

	var version struct {
		AssetIndex struct {
			URL string `json:"url"`
		} `json:"assetIndex"`
	}

	versionRes, err := httpGetter(versionURL)
	if err != nil {
		return "", fmt.Errorf("could not reach versionURL: %w", err)
	}
	defer versionRes.Body.Close()

	if versionRes.StatusCode != http.StatusOK {
		return "", fmt.Errorf("non OK status response %d fetching version JSON", versionRes.StatusCode)
	}

	if err := json.NewDecoder(versionRes.Body).Decode(&version); err != nil {
		return "", fmt.Errorf("could not decode version JSON: %w", err)
	}

	return version.AssetIndex.URL, nil
}
