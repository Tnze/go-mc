//go:build generate
// +build generate

package main

import (
	"encoding/json"
	"github.com/iancoleman/strcase"
	"net/http"
	"os"
	"text/template"
)

const (
	version = "1.19"
	infoURL = "https://raw.githubusercontent.com/PrismarineJS/minecraft-data/master/data/pc/" + version + "/enchantments.json"
	//language=gohtml
	enchantmentTmpl = `// Code generated by gen_enchantments.go DO NOT EDIT.
// Package enchantments stores information about enchantments in Minecraft.
package enchantments

// ID describes the numeric ID of an enchantment.
type ID uint32

// For more informations about the MinCost and MaxCost fields, see 
// https://github.com/PrismarineJS/prismarine-rng/blob/cd4fd9eeda6ea72e428d172a08a99ff4e4ac0394/lib/enchantments.js#L72 and
// https://github.com/PrismarineJS/minecraft-data-generator-server/blob/4395173dd97148f545b3392540d12bc70ebe0bf5/src/main/java/dev/u9g/minecraftdatagenerator/generators/EnchantmentsDataGenerator.java#L83

// MinCost describes the minimum cost of an enchantment.
type MinCost struct {
	Level int32
	Cost  int32
}

// MaxCost describes the maximum cost of an enchantment.
type MaxCost struct {
	Level int32
	Cost  int32
}

// Enchantment describes information about a type of enchantment.
type Enchantment struct {
	ID          ID
	DisplayName  string
	Name         string
	MaxLevel     uint
	MinCost      MinCost
	MaxCost      MaxCost
	Exclude      []string
 	Category     string
    Weight       int32
    TreasureOnly bool
    Curse        bool
	Tradeable    bool
	Discoverable bool
}

var (
	{{- range .}}
	{{.CamelName}} = Enchantment{
		ID: {{.ID}},
		DisplayName: "{{.DisplayName}}",
		Name: "{{.Name}}",
		MaxLevel: {{.MaxLevel}},
		MinCost: MinCost{
			Level: {{.MinCost.Level}},
			Cost: {{.MinCost.Cost}},
		},
		MaxCost: MaxCost{
			Level: {{.MaxCost.Level}},
			Cost: {{.MaxCost.Cost}},
		},
		Exclude: []string{ {{range .Exclude}}
			"{{.}}",{{end}}
		},
		Category: "{{.Category}}",
		Weight: {{.Weight}},
		TreasureOnly: {{.TreasureOnly}},
		Curse: {{.Curse}},
		Tradeable: {{.Tradeable}},
		Discoverable: {{.Discoverable}},
	}{{end}}
)

// ByID is an index of minecraft enchantments by their ID.
var ByID = map[ID]*Enchantment{ {{range .}}
	{{.ID}}: &{{.CamelName}},{{end}}
}

// ByName is an index of minecraft enchantments by their name.
var ByName = map[string]*Enchantment{ {{range .}}
	"{{.Name}}": &{{.CamelName}},{{end}}
}

// ByDisplayName is an index of minecraft enchantments by their display name.
var ByDisplayName = map[string]*Enchantment{ {{range .}}
	"{{.DisplayName}}": &{{.CamelName}},{{end}}
}`
)

type Enchantment struct {
	ID          uint32 `json:"id"`
	CamelName   string `json:"-"`
	DisplayName string `json:"displayName"`
	Name        string `json:"name"`
	MaxLevel    uint   `json:"maxLevel"`
	MinCost     struct {
		Level int32 `json:"a"`
		Cost  int32 `json:"b"`
	} `json:"minCost"`
	MaxCost struct {
		Level int32 `json:"a"`
		Cost  int32 `json:"b"`
	} `json:"maxCost"`
	Exclude      []string `json:"exclude"`
	Category     string   `json:"category"`
	Weight       int32    `json:"weight"`
	TreasureOnly bool     `json:"treasureOnly"`
	Curse        bool     `json:"curse"`
	Tradeable    bool     `json:"tradeable"`
	Discoverable bool     `json:"discoverable"`
}

func downloadInfo() ([]*Enchantment, error) {
	resp, err := http.Get(infoURL)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var data []*Enchantment
	if err := json.NewDecoder(resp.Body).Decode(&data); err != nil {
		return nil, err
	}
	for _, d := range data {
		d.CamelName = strcase.ToCamel(d.Name)
	}
	return data, nil
}

//go:generate go run $GOFILE
//go:generate go fmt enchantments.go
func main() {
	data, err := downloadInfo()
	if err != nil {
		panic(err)
	}

	tmpl, err := template.New("effects").Parse(enchantmentTmpl)
	if err != nil {
		panic(err)
	}

	f, err := os.Create("enchantments.go")
	if err != nil {
		panic(err)
	}
	defer f.Close()

	if err := tmpl.Execute(f, data); err != nil {
		panic(err)
	}
}
