package nbt

import (
	"bytes"
	"compress/gzip"
	"io"
	"math"
	"reflect"
	"strconv"
	"strings"
	"testing"
)

func TestUnmarshal_string(t *testing.T) {
	data := []byte{
		0x08, 0x00, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x00, 0x09,
		0x42, 0x61, 0x6e, 0x61, 0x6e, 0x72, 0x61, 0x6d, 0x61,
	}

	// Unmarshal to string
	var Name string
	if err := Unmarshal(data, &Name); err != nil {
		t.Fatal(err)
	}

	if Name != "Bananrama" {
		t.Errorf("Unmarshal NBT fail: get %q, want %q", Name, "Bananrama")
	}

	// Unmarshal to any
	var infName any
	if err := Unmarshal(data, &infName); err != nil {
		t.Fatal(err)
	}

	if infName != "Bananrama" {
		t.Errorf("Unmarshal NBT fail: get %q, want %q", Name, "Bananrama")
	}
}

func TestUnmarshal_simple(t *testing.T) {
	data := []byte{
		0x0a, 0x00, 0x0b, 0x68, 0x65, 0x6c, 0x6c, 0x6f,
		0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x08, 0x00,
		0x04, 0x6e, 0x61, 0x6d, 0x65, 0x00, 0x09, 0x42,
		0x61, 0x6e, 0x61, 0x6e, 0x72, 0x61, 0x6d, 0x61,
		0x00,
	}

	// test parse
	var value struct {
		Name string `nbt:"name"`
	}
	if err := Unmarshal(data, &value); err != nil {
		t.Fatal(err)
	}
	if value.Name != "Bananrama" {
		t.Errorf("Unmarshal NBT fail: get %q, want %q", value.Name, "Bananrama")
	}

	// test rawRead
	var empty struct{}
	if err := Unmarshal(data, &empty); err != nil {
		t.Fatal(err)
	}
}

// Generated by vscode-hexdump
var bigTestData = [...]byte{
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xed, 0x54, 0xcf, 0x4f, 0x1a, 0x41,
	0x14, 0x7e, 0xc2, 0x02, 0xcb, 0x96, 0x82, 0xb1,
	0xc4, 0x10, 0x63, 0xcc, 0xab, 0xb5, 0x84, 0xa5,
	0xdb, 0xcd, 0x42, 0x11, 0x89, 0xb1, 0x88, 0x16,
	0x2c, 0x9a, 0x0d, 0x1a, 0xd8, 0xa8, 0x31, 0x86,
	0xb8, 0x2b, 0xc3, 0x82, 0x2e, 0xbb, 0x66, 0x77,
	0xb0, 0xf1, 0xd4, 0x4b, 0x7b, 0x6c, 0x7a, 0xeb,
	0x3f, 0xd3, 0x23, 0x7f, 0x43, 0xcf, 0xbd, 0xf6,
	0xbf, 0xa0, 0xc3, 0x2f, 0x7b, 0x69, 0xcf, 0xbd,
	0xf0, 0x32, 0xc9, 0xf7, 0xe6, 0xbd, 0x6f, 0xe6,
	0x7b, 0x6f, 0x26, 0x79, 0x02, 0x04, 0x54, 0x72,
	0x4f, 0x2c, 0x0e, 0x78, 0xcb, 0xb1, 0x4d, 0x8d,
	0x78, 0xf4, 0xe3, 0x70, 0x62, 0x3e, 0x08, 0x7b,
	0x1d, 0xc7, 0xa5, 0x93, 0x18, 0x0f, 0x82, 0x47,
	0xdd, 0xee, 0x84, 0x02, 0x62, 0xb5, 0xa2, 0xaa,
	0xc7, 0x78, 0x76, 0x5c, 0x57, 0xcb, 0xa8, 0x55,
	0x0f, 0x1b, 0xc8, 0xd6, 0x1e, 0x6a, 0x95, 0x86,
	0x86, 0x0d, 0xad, 0x7e, 0x58, 0x7b, 0x8f, 0x83,
	0xcf, 0x83, 0x4f, 0x83, 0x6f, 0xcf, 0x03, 0x10,
	0x6e, 0x5b, 0x8e, 0x3e, 0xbe, 0xa5, 0x38, 0x4c,
	0x64, 0xfd, 0x10, 0xea, 0xda, 0x74, 0xa6, 0x23,
	0x40, 0xdc, 0x66, 0x2e, 0x69, 0xe1, 0xb5, 0xd3,
	0xbb, 0x73, 0xfa, 0x76, 0x0b, 0x29, 0xdb, 0x0b,
	0xe0, 0xef, 0xe8, 0x3d, 0x1e, 0x38, 0x5b, 0xef,
	0x11, 0x08, 0x56, 0xf5, 0xde, 0x5d, 0xdf, 0x0b,
	0x40, 0xe0, 0x5e, 0xb7, 0xfa, 0x64, 0xb7, 0x04,
	0x00, 0x8c, 0x41, 0x4c, 0x73, 0xc6, 0x08, 0x55,
	0x4c, 0xd3, 0x20, 0x2e, 0x7d, 0xa4, 0xc0, 0xc8,
	0xc2, 0x10, 0xb3, 0xba, 0xde, 0x58, 0x0b, 0x53,
	0xa3, 0xee, 0x44, 0x8e, 0x45, 0x03, 0x30, 0xb1,
	0x27, 0x53, 0x8c, 0x4c, 0xf1, 0xe9, 0x14, 0xa3,
	0x53, 0x8c, 0x85, 0xe1, 0xd9, 0x9f, 0xe3, 0xb3,
	0xf2, 0x44, 0x81, 0xa5, 0x7c, 0x33, 0xdd, 0xd8,
	0xbb, 0xc7, 0xaa, 0x75, 0x13, 0x5f, 0x28, 0x1c,
	0x08, 0xd7, 0x2e, 0xd1, 0x59, 0x3f, 0xaf, 0x1d,
	0x1b, 0x60, 0x21, 0x59, 0xdf, 0xfa, 0xf1, 0x05,
	0xfe, 0xc1, 0xce, 0xfc, 0x9d, 0xbd, 0x00, 0xbc,
	0xf1, 0x40, 0xc9, 0xf8, 0x85, 0x42, 0x40, 0x46,
	0xfe, 0x9e, 0xeb, 0xea, 0x0f, 0x93, 0x3a, 0x68,
	0x87, 0x60, 0xbb, 0xeb, 0x32, 0x37, 0xa3, 0x28,
	0x0a, 0x8e, 0xbb, 0xf5, 0xd0, 0x69, 0x63, 0xca,
	0x4e, 0xdb, 0xe9, 0xec, 0xe6, 0xe6, 0x2b, 0x3b,
	0xbd, 0x25, 0xbe, 0x64, 0x49, 0x09, 0x3d, 0xaa,
	0xbb, 0x94, 0xfd, 0x18, 0x7e, 0xe8, 0xd2, 0x0e,
	0xda, 0x6f, 0x15, 0x4c, 0xb1, 0x68, 0x3e, 0x2b,
	0xe1, 0x9b, 0x9c, 0x84, 0x99, 0xbc, 0x84, 0x05,
	0x09, 0x65, 0x59, 0x16, 0x45, 0x00, 0xff, 0x2f,
	0x28, 0xae, 0x2f, 0xf2, 0xc2, 0xb2, 0xa4, 0x2e,
	0x1d, 0x20, 0x77, 0x5a, 0x3b, 0xb9, 0x8c, 0xca,
	0xe7, 0x29, 0xdf, 0x51, 0x41, 0xc9, 0x16, 0xb5,
	0xc5, 0x6d, 0xa1, 0x2a, 0xad, 0x2c, 0xc5, 0x31,
	0x7f, 0xba, 0x7a, 0x92, 0x8e, 0x5e, 0x9d, 0x5f,
	0xf8, 0x12, 0x05, 0x23, 0x1b, 0xd1, 0xf6, 0xb7,
	0x77, 0xaa, 0xcd, 0x95, 0x72, 0xbc, 0x9e, 0xdf,
	0x58, 0x5d, 0x4b, 0x97, 0xae, 0x92, 0x17, 0xb9,
	0x44, 0xd0, 0x80, 0xc8, 0xfa, 0x3e, 0xbf, 0xb3,
	0xdc, 0x54, 0xcb, 0x07, 0x75, 0x6e, 0xa3, 0xb6,
	0x76, 0x59, 0x92, 0x93, 0xa9, 0xdc, 0x51, 0x50,
	0x99, 0x6b, 0xcc, 0x35, 0xe6, 0x1a, 0xff, 0x57,
	0x23, 0x08, 0x42, 0xcb, 0xe9, 0x1b, 0xd6, 0x78,
	0xc2, 0xec, 0xfe, 0xfc, 0x7a, 0xfb, 0x7d, 0x78,
	0xd3, 0x84, 0xdf, 0xd4, 0xf2, 0xa4, 0xfb, 0x08,
	0x06, 0x00, 0x00,
}

type BigTestStruct struct {
	LongTest   int64   `nbt:"longTest"`
	ShortTest  int16   `nbt:"shortTest"`
	StringTest string  `nbt:"stringTest"`
	FloatTest  float32 `nbt:"floatTest"`
	IntTest    int32   `nbt:"intTest"`
	NCT        struct {
		Ham struct {
			Name  string  `nbt:"name"`
			Value float32 `nbt:"value"`
		} `nbt:"ham"`
		Egg struct {
			Name  string  `nbt:"name"`
			Value float32 `nbt:"value"`
		} `nbt:"egg"`
	} `nbt:"nested compound test"`
	ListTest  []int64 `nbt:"listTest (long),list"`
	ListTest2 [2]struct {
		Name      string `nbt:"name"`
		CreatedOn int64  `nbt:"created-on"`
	} `nbt:"listTest (compound)"`
	ByteTest      byte    `nbt:"byteTest"`
	ByteArrayTest []byte  `nbtkey:"byteArrayTest (the first 1000 values of (n*n*255+n*7)%100, starting with n=0 (0, 62, 34, 16, 8, ...))"`
	DoubleTest    float64 `nbt:"doubleTest"`
}

func MakeBigTestStruct() BigTestStruct {
	var want BigTestStruct
	want.NCT.Egg.Name = "Eggbert"
	want.NCT.Egg.Value = 0.5
	want.NCT.Ham.Name = "Hampus"
	want.NCT.Ham.Value = 0.75
	want.IntTest = 2147483647
	want.ByteTest = 127
	want.StringTest = "HELLO WORLD THIS IS A TEST STRING \xc3\x85\xc3\x84\xc3\x96!"
	want.ListTest = []int64{11, 12, 13, 14, 15}
	want.DoubleTest = 0.49312871321823148
	want.FloatTest = 0.49823147058486938
	want.LongTest = 9223372036854775807
	want.ListTest2[0].CreatedOn = 1264099775885
	want.ListTest2[0].Name = "Compound tag #0"
	want.ListTest2[1].CreatedOn = 1264099775885
	want.ListTest2[1].Name = "Compound tag #1"
	want.ByteArrayTest = make([]byte, 1000)
	for n := 0; n < 1000; n++ {
		want.ByteArrayTest[n] = byte((n*n*255 + n*7) % 100)
	}
	want.ShortTest = 32767
	return want
}

func TestDecoder_Decode_bigTest(t *testing.T) {
	// test parse
	var value BigTestStruct
	r, err := gzip.NewReader(bytes.NewReader(bigTestData[:]))
	if err != nil {
		t.Fatal(err)
	}
	if _, err := NewDecoder(r).Decode(&value); err != nil {
		t.Fatal(err)
	}

	want := MakeBigTestStruct()
	if !reflect.DeepEqual(value, want) {
		t.Errorf("parse fail, expect %v, get %v", want, value)
	}

	// test rawRead
	var empty struct{}
	r, err = gzip.NewReader(bytes.NewReader(bigTestData[:]))
	if err != nil {
		t.Fatal(err)
	}
	if _, err := NewDecoder(r).Decode(&empty); err != nil {
		t.Fatal(err)
	}

	var inf any
	r, err = gzip.NewReader(bytes.NewReader(bigTestData[:]))
	if err != nil {
		t.Fatal(err)
	}
	if _, err := NewDecoder(r).Decode(&inf); err != nil {
		t.Fatal(err)
	}
	// t.Log(inf)
}

func BenchmarkDecoder_Decode_bigTest(b *testing.B) {
	var value BigTestStruct
	for i := 0; i < b.N; i++ {
		r, err := gzip.NewReader(bytes.NewReader(bigTestData[:]))
		if err != nil {
			b.Fatal(err)
		}
		if _, err := NewDecoder(r).Decode(&value); err != nil {
			b.Fatal(err)
		}
	}

	want := MakeBigTestStruct()
	if !reflect.DeepEqual(value, want) {
		b.Errorf("parse fail, expect %v, get %v", want, value)
	}
}

func TestDecoder_overRead(t *testing.T) {
	const tail = 16
	// Uncompressed NBT
	enc := []byte{
		TagCompound, 0, 1, 'A',
		TagString, 0, 1, 'B', 0, 0,
		TagEnd,
	}
	dataLen := len(enc)
	// these zeros are honeypot, we should not read them
	enc = append(enc, make([]byte, tail)...)

	var value struct {
		B string
	}

	r := bytes.NewReader(enc)
	// Count read bytes by using io.LimitReader
	rr := io.LimitReader(r, math.MaxInt64).(*io.LimitedReader)
	if _, err := NewDecoder(rr).Decode(&value); err != nil {
		t.Fatal(err)
	}

	readBytesNum := math.MaxInt64 - rr.N
	if readBytesNum > int64(dataLen) || r.Len() < tail {
		t.Errorf("Over read! nbt length: %d, but you read %d", dataLen, readBytesNum)
	}
}

func TestDecoder_Decode_IntArray(t *testing.T) {
	data := []byte{
		TagIntArray, 0, 0,
		0, 0, 0, 3,

		0, 0, 0, 1,
		0, 0, 0, 2,
		0, 0, 0, 3,
	}
	var (
		value []int
		want  = []int{1, 2, 3}

		value2 []int32
		want2  = []int32{1, 2, 3}
	)

	if err := Unmarshal(data, &value); err != nil {
		t.Fatal(err)
	}
	if !reflect.DeepEqual(value, want) {
		t.Errorf("parse fail, expect %v, get %v", want, value)
	}

	if err := Unmarshal(data, &value2); err != nil {
		t.Fatal(err)
	}
	if !reflect.DeepEqual(value2, want2) {
		t.Errorf("parse fail, expect %v, get %v", want2, value2)
	}

	// t.Log(value, value2)
}

func TestDecoder_Decode_LongArray(t *testing.T) {
	data := []byte{
		TagLongArray, 0, 0,
		0, 0, 0, 3,

		0, 0, 0, 0, 0, 0, 0, 1,
		0, 0, 0, 0, 0, 0, 0, 2,
		0, 0, 0, 0, 0, 0, 0, 3,
	}
	var (
		value    []int64
		infValue any
		want     = []int64{1, 2, 3}
	)

	if err := Unmarshal(data, &value); err != nil {
		t.Fatal(err)
	}
	if !reflect.DeepEqual(value, want) {
		t.Errorf("parse fail, expect %v, get %v", want, value)
	}
	// t.Log(value)

	if err := Unmarshal(data, &infValue); err != nil {
		t.Fatal(err)
	}
	if !reflect.DeepEqual(infValue, want) {
		t.Errorf("parse fail, expect %v, get %v", want, infValue)
	}
	// t.Log(infValue)
}

func TestDecoder_Decode_ByteArray(t *testing.T) {
	data := []byte{
		TagByteArray, 0, 0,
		0, 0, 0, 7,
		0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
	}
	var (
		value    []byte
		infValue any
		want     = []byte{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07}
	)

	// Unmarshal to []byte
	if err := Unmarshal(data, &value); err != nil {
		t.Fatal(err)
	}
	if !reflect.DeepEqual(value, want) {
		t.Errorf("parse fail, expect %v, get %v", want, value)
	}
	// t.Log(value)

	// Unmarshal to any
	if err := Unmarshal(data, &infValue); err != nil {
		t.Fatal(err)
	}
	if !reflect.DeepEqual(infValue, want) {
		t.Errorf("parse fail, expect %v, get %v", want, value)
	}
	// t.Log(infValue)
}

func TestDecoder_Decode_bool(t *testing.T) {
	data := [][]byte{
		{TagByte, 0, 0, 0},
		{TagByte, 0, 0, 1},
		{TagByte, 0, 0, 2},
		{TagByte, 0, 0, 128},
		{TagByte, 0, 0, 255},
	}
	want := []bool{
		false, true, true, true, true,
	}
	var value bool
	for i, v := range data {
		// Unmarshal to []byte
		if err := Unmarshal(v, &value); err != nil {
			t.Fatal(err)
		}
		if value != want[i] {
			t.Errorf("parse fail, expect %v, get %v", want, value)
		}
	}
}

func TestDecoder_Decode_ErrorString(t *testing.T) {
	data := []byte{
		0x08, 0x00, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0xFF, 0xFE,
		0x42, 0x61, 0x6e, 0x61, 0x6e, 0x72, 0x61, 0x6d, 0x61,
	}

	// Unmarshal to string
	var Name string
	err := Unmarshal(data, &Name)

	if err == nil {
		t.Error("should return a error if len < 0")
	}
	t.Log(err)
}

type TextBool bool

func (b TextBool) MarshalText() (text []byte, err error) {
	return []byte(strconv.FormatBool(bool(b))), nil
}

func (b *TextBool) UnmarshalText(text []byte) (err error) {
	*((*bool)(b)), err = strconv.ParseBool(string(text))
	return
}

func TestDecoder_Decode_textUnmarshaler(t *testing.T) {
	var b TextBool
	data := []byte{
		TagString, 0, 0,
		0, 4, 't', 'r', 'u', 'e',
	}
	_, err := NewDecoder(bytes.NewReader(data)).Decode(&b)
	if err != nil {
		t.Fatal(err)
	}
	if b != true {
		t.Errorf("b should be true")
	}

	var s struct {
		A TextBool
	}
	data = []byte{
		TagCompound, 0, 0,
		TagString, 0, 1, 'A', 0, 4, 't', 'r', 'u', 'e',
		TagEnd,
	}
	_, err = NewDecoder(bytes.NewReader(data)).Decode(&s)
	if err != nil {
		t.Fatal(err)
	}
	if s.A != true {
		t.Errorf("s.A should be true")
	}
}

func TestDecoder_Decode_ErrorUnknownField(t *testing.T) {
	data := []byte{
		TagCompound, 0, 1, 'S',
		TagByte, 0, 1, 'A', 1,
		TagByte, 0, 1, 'B', 2,
		TagEnd,
	}
	var v struct {
		A byte `nbt:"a"`
	}
	d := NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if _, err := d.Decode(&v); err == nil || !strings.Contains(err.Error(), "unknown field") {
		t.Errorf("should return an error unmarshalling unknown field")
	}
}

func TestDecoder_Decode_keysWithComma(t *testing.T) {
	data := []byte{
		TagCompound, 0, 1, 'S',
		TagString, 0, 1, 't',
		0, 4, 'T', 'n', 'z', 'e',
		TagEnd,
	}
	var s struct {
		T string `nbt:"t,omitempty"`
	}

	if _, err := NewDecoder(bytes.NewReader(data)).Decode(&s); err != nil {
		t.Errorf("decode error: %v", err)
	}

	want := "Tnze"
	if s.T != want {
		t.Errorf("unmarshal error: got %q, want %q", s.T, want)
	}
}

func TestDecoder_Decode_keysWithComma2(t *testing.T) {
	data := []byte{
		TagCompound, 0, 1, 'S',
		TagString, 0, 11, 't', ',', 'o', 'm', 'i', 't', 'e', 'm', 'p', 't', 'y',
		0, 4, 'T', 'n', 'z', 'e',
		TagEnd,
	}
	var s struct {
		T string `nbtkey:"t,omitempty"`
	}

	if _, err := NewDecoder(bytes.NewReader(data)).Decode(&s); err != nil {
		t.Errorf("decode error: %v", err)
	}

	want := "Tnze"
	if s.T != want {
		t.Errorf("unmarshal error: got %q, want %q", s.T, want)
	}
}
